declare const ResultDoesNotContainError_base: import("./CustomErrorConstructor").CustomErrorConstructor<any, "ResultDoesNotContainError">;
declare class ResultDoesNotContainError extends ResultDoesNotContainError_base {
}
interface ResultBase<TValue, TError extends Error> {
    hasError: () => this is ResultError<TValue, TError>;
    hasValue: () => this is ResultValue<TValue, TError>;
    unwrapOrThrow: (errorTransformer?: (err: TError) => Error) => TValue;
    unwrapOrElse: (handleError: (error: Error) => TValue) => TValue;
    unwrapOrDefault: <TDefault = TValue>(defaultValue: TDefault) => TValue | TDefault;
    unwrapErrorOrThrow: () => TError;
}
interface ResultError<TValue, TError extends Error> extends ResultBase<TValue, TError> {
    error: TError;
}
declare const error: <TValue, TError extends Error>(err: TError) => ResultError<TValue, TError>;
interface ResultValue<TValue, TError extends Error> extends ResultBase<TValue, TError> {
    value: TValue;
}
declare const value: {
    <TValue extends undefined, TError extends Error>(): ResultValue<TValue, TError>;
    <TValue, TError extends Error>(value: TValue): ResultValue<TValue, TError>;
};
declare type Result<TValue, TError extends Error> = ResultValue<TValue, TError> | ResultError<TValue, TError>;
export type { ResultValue, ResultError, Result };
export { ResultDoesNotContainError, value, error };
